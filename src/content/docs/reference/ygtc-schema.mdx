---
title: "YGTC Schema"
description: "Complete specification for YGTc v2 flow files"
---

# YGTC Schema

YGTC (YAML Greentic Configuration) is the declarative format for defining flows in Greentic. This reference covers the **v2 schema** which is the current standard.

## Overview

A YGTC file defines:
- Flow metadata (id, type, title, description)
- Parameters for flow-level configuration
- Nodes that execute operations
- Routing between nodes

## Basic Structure

```yaml
id: weather-bot
title: Weather Bot
description: Ask for a location and get a weather forecast
type: messaging
start: collect_location

parameters:
  days_default: 3

nodes:
  collect_location:
    qa.process:
      welcome: "Hi there! Let's get your weather forecast."
      questions:
        - id: q_location
          prompt: "Which city do you want to check?"
          answer_type: text
    routing:
      - to: forecast

  forecast:
    mcp.exec:
      component: weather_api
      action: forecast_weather
      args:
        q: collect_location.q_location
        days: parameters.days_default
    routing:
      - to: respond

  respond:
    templating.handlebars:
      text: "Weather for {{forecast.payload.location.name}}: {{forecast.payload.current.temp_c}}°C"
    routing:
      - out: true
```

## Flow Metadata

### Required Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique identifier (lowercase, hyphens allowed) |
| `type` | string | Flow type: `messaging`, `webhook`, `timer`, `websocket`, `pubsub`, or custom |
| `nodes` | object | Node definitions (minimum 1 node) |

### Optional Fields

| Field | Type | Description |
|-------|------|-------------|
| `title` | string | Human-readable title |
| `description` | string | Flow description |
| `tags` | array | Tags for categorisation |
| `start` | string | Name of the first node to execute |
| `parameters` | object | Flow-level parameters accessible in nodes |
| `entrypoints` | object | Named entrypoints (e.g., `default`, `telegram`, `http:/path`) |
| `schema_version` | integer | Schema version (default: 2) |

### Flow Types

| Type | Description |
|------|-------------|
| `messaging` | Triggered by incoming messages (chat bots, support agents) |
| `webhook` | Triggered by HTTP webhooks |
| `timer` | Triggered on schedule |
| `websocket` | WebSocket connections |
| `pubsub` | Pub/sub event triggers |

**Example types:**

```yaml
# Messaging flow (chat bot)
id: support-bot
type: messaging
start: greet
```

```yaml
# Webhook flow
id: github-webhook
type: webhook
start: process
```

```yaml
# Timer flow (scheduled)
id: daily-report
type: timer
start: generate
```

## Nodes

Nodes are the steps in a flow. Each node has:
- **One operation key** — The action to perform
- **Routing** — Where to go next
- **Optional metadata** — Telemetry, retry, timeout, conditions

### Node Structure

```yaml
nodes:
  node-name:
    operation.name:          # Operation key
      key: value             # Operation config (NO config: wrapper)
      another_key: value
    routing:                 # Where to go next
      - to: next-node
    telemetry:              # Optional
      span_name: "process-user"
    retry:                  # Optional
      max_attempts: 3
    timeout:                # Optional
      seconds: 30
    when:                   # Optional condition
      expression: "{{state.ready}}"
```

### Operation Keys

Operations are named actions like `qa.process`, `mcp.exec`, `templating.handlebars`. The operation key identifies what the node does:

```yaml
# Q&A processing
collect_info:
  qa.process:
    welcome: "Hello!"
    questions:
      - id: name
        prompt: "What's your name?"
        answer_type: text

# MCP tool execution
call_api:
  mcp.exec:
    component: my_api
    action: get_data
    args:
      id: "{{collect_info.name}}"

# Handlebars templating
respond:
  templating.handlebars:
    text: "Hello {{collect_info.name}}!"
```

**Important:** Configuration goes directly under the operation key. There is **no `config:` wrapper**.

```yaml
# CORRECT - config directly under operation
my_node:
  templating.handlebars:
    text: "Hello world"

# WRONG - do not use config: wrapper
my_node:
  templating.handlebars:
    config:              # NO! Don't do this
      text: "Hello world"
```

### Common Operations

| Operation | Description |
|-----------|-------------|
| `qa.process` | Structured Q&A collection |
| `mcp.exec` | Execute MCP tool |
| `templating.handlebars` | Handlebars template rendering |
| `handle_message` | Generic message handling |

## Routing

Routing determines which node executes next. YGTc v2 supports:

### Shorthand Routing

For simple terminal nodes:

```yaml
routing: out      # Terminal - end flow
routing: reply    # Reply to origin and end
```

### Array Routing

For explicit routing:

```yaml
# Single next node
routing:
  - to: next-node

# Terminal node
routing:
  - out: true

# Reply and continue
routing:
  - reply: true
  - to: next-node

# Multiple targets (fan-out)
routing:
  - to: handler-a
  - to: handler-b
```

### Routing Properties

| Property | Type | Description |
|----------|------|-------------|
| `to` | string | Target node name |
| `out` | boolean | Terminal edge (end flow) |
| `reply` | boolean | Reply to origin |
| `status` | string | Status code for routing |

### Conditional Routing

For conditional routing, use `when` on the node:

```yaml
nodes:
  check:
    handle_message:
      input: "{{in.text}}"
    routing:
      - to: high_priority
      - to: low_priority

  high_priority:
    when:
      expression: "{{check.priority}} == 'high'"
    templating.handlebars:
      text: "Urgent!"
    routing: out

  low_priority:
    when:
      expression: "{{check.priority}} != 'high'"
    templating.handlebars:
      text: "Standard."
    routing: out
```

## Parameters

Flow-level parameters accessible throughout the flow:

```yaml
parameters:
  default_model: gpt-4o
  max_retries: 3
  api_base: "https://api.example.com"

nodes:
  call_llm:
    mcp.exec:
      component: llm
      action: chat
      args:
        model: parameters.default_model
```

## Data References

Reference data from previous nodes, parameters, and context:

### Previous Node Output

```yaml
# Reference output from 'collect_info' node
text: "Hello {{collect_info.name}}"
location: collect_info.q_location
```

### Parameters

```yaml
# Reference flow parameters
days: parameters.days_default
```

### Nested Access

```yaml
# Access nested properties
city: "{{forecast.payload.location.name}}"
temp: "{{forecast.payload.current.temp_c}}"
```

### Handlebars Iteration

```yaml
templating.handlebars:
  text: |
    Forecast:
    {{#forecast.payload.forecast}}
    - {{date}}: {{day.condition.text}}
    {{/forecast.payload.forecast}}
```

## Node Metadata

### Telemetry

Custom span names and attributes for observability:

```yaml
my_node:
  qa.process:
    questions: [...]
  telemetry:
    span_name: "collect-user-info"
    attributes:
      flow_step: "intake"
      category: "user"
    sampling: "always"
```

### Retry

Retry configuration for transient failures:

```yaml
my_node:
  mcp.exec:
    component: external_api
    action: fetch
  retry:
    max_attempts: 3
    delay_ms: 1000
    backoff: exponential
```

### Timeout

Execution timeout:

```yaml
my_node:
  mcp.exec:
    component: slow_api
    action: process
  timeout:
    seconds: 60
```

### Annotations and Meta

Custom metadata for tooling:

```yaml
my_node:
  qa.process:
    questions: [...]
  annotations:
    author: "team-a"
    version: "1.0"
  meta:
    custom_field: "value"
```

## Complete Example

Here's a complete weather bot flow demonstrating all concepts:

```yaml
id: weather_bot
title: Weather Bot
description: Ask for a location, call the MCP weather API, and reply with a forecast.
type: messaging
start: collect_location

parameters:
  days_default: 3

nodes:
  collect_location:
    qa.process:
      welcome: "Hi there! Let's get your weather forecast."
      questions:
        - id: q_location
          prompt: "Which city do you want to check?"
          answer_type: text
          max_words: 5
    routing:
      - to: forecast_weather

  forecast_weather:
    mcp.exec:
      component: weather_api
      action: forecast_weather
      args:
        q: collect_location.q_location
        days: parameters.days_default
    routing:
      - to: weather_text

  weather_text:
    templating.handlebars:
      text: |
        Here's the forecast for {{forecast_weather.payload.location.name}}, {{forecast_weather.payload.location.country}}:

        Now: {{forecast_weather.payload.current.condition.text}}, {{forecast_weather.payload.current.temp_c}}°C
        Wind: {{forecast_weather.payload.current.wind_kph}} kph | Humidity: {{forecast_weather.payload.current.humidity}}%

        Forecast (next {{parameters.days_default}} day(s)):
        {{#forecast_weather.payload.forecast}}
        - {{date}}: ↑ {{day.maxtemp_c}}°C | ↓ {{day.mintemp_c}}°C — {{day.condition.text}}
        {{/forecast_weather.payload.forecast}}
    routing:
      - out: true
```

## Sidecar Files

YGTc v2 flows use a **sidecar file** (`<flow>.ygtc.resolve.json`) to track component bindings. This separates the flow logic from component sources:

```json
{
  "schema_version": 1,
  "nodes": {
    "collect_location": {
      "source": {
        "kind": "remote",
        "reference": "oci://ghcr.io/greentic-ai/components/qa:0.1.0"
      }
    },
    "forecast_weather": {
      "source": {
        "kind": "local",
        "path": "components/weather/target/wasm32-wasip2/release/weather.wasm"
      }
    }
  }
}
```

The sidecar is managed by `greentic-flow` commands. You don't edit it manually.

## Schema Validation

Validate your flow:

```bash
# Validate a single flow
greentic-flow doctor flows/weather_bot.ygtc

# Validate all flows in a directory
greentic-flow doctor flows/

# JSON output for CI
greentic-flow doctor --json flows/weather_bot.ygtc
```

Full JSON Schema:
```
https://raw.githubusercontent.com/greentic-ai/greentic-flow/refs/heads/master/schemas/ygtc.flow.schema.json
```

## Migration from v1

If you have legacy flows using the `component.name` syntax with `config:` wrappers:

**v1 (legacy):**
```yaml
nodes:
  my-node:
    component.template:
      config:
        template: "Hello {{name}}"
    routing:
      next: other-node
```

**v2 (current):**
```yaml
nodes:
  my-node:
    templating.handlebars:
      text: "Hello {{name}}"
    routing:
      - to: other-node
```

Key changes:
1. Operation keys replace `component.name` (e.g., `templating.handlebars`)
2. No `config:` wrapper - config goes directly under operation
3. Routing uses array format with `to:` key
4. Use `- out: true` instead of `next: __end__`

## Related

- [Flows](/docs/architecture/flows) — Flow concepts
- [CLI Reference](/docs/reference/cli) — CLI commands
- [Component Manifest](/docs/reference/component-manifest) — Component specification
