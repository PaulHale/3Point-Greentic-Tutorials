---
title: "MCP Tools"
description: "Using and creating Model Context Protocol tools in Greentic"
---

# MCP Tools

Tools are the primary way for AI models to interact with the outside world through MCP. Greentic provides built-in tools and supports custom tool creation.

## What are Tools?

Tools are functions that AI models can call to:

- Fetch data from APIs
- Query databases
- Execute code
- Interact with external services
- Perform calculations

## Built-in Tools

Greentic includes several built-in tools:

### HTTP Tool

Make HTTP requests:

```yaml
# In mcp-config.json
{
  "tools": {
    "http_request": {
      "type": "http",
      "description": "Make HTTP requests to external APIs",
      "schema": {
        "input": {
          "type": "object",
          "properties": {
            "url": { "type": "string" },
            "method": { "type": "string", "enum": ["GET", "POST", "PUT", "DELETE"] },
            "body": { "type": "object" }
          },
          "required": ["url", "method"]
        }
      }
    }
  }
}
```

### Database Tool

Query databases:

```json
{
  "tools": {
    "query_database": {
      "type": "sql",
      "description": "Execute SQL queries",
      "config": {
        "connection_string_secret": "DATABASE_URL"
      },
      "schema": {
        "input": {
          "type": "object",
          "properties": {
            "query": { "type": "string" },
            "database": { "type": "string" }
          },
          "required": ["query"]
        }
      }
    }
  }
}
```

### Vector Search Tool

Search vector stores:

```json
{
  "tools": {
    "vector_search": {
      "type": "http",
      "endpoint": "http://vector-db:8000/search",
      "description": "Search for similar documents",
      "schema": {
        "input": {
          "type": "object",
          "properties": {
            "query": { "type": "string" },
            "top_k": { "type": "integer", "default": 5 },
            "collection": { "type": "string" }
          },
          "required": ["query", "collection"]
        }
      }
    }
  }
}
```

## Using Tools in Flows

### Direct Tool Invocation

Call a specific tool using `mcp.exec`:

```yaml
id: tool-flow
type: messaging
start: search

nodes:
  search:
    mcp.exec:
      component: vector_db
      action: search
      args:
        query: "{{in.text}}"
        collection: knowledge-base
        top_k: 5
    routing:
      - to: process_results

  process_results:
    templating.handlebars:
      text: |
        Found {{search.results.length}} results:
        {{#search.results}}
        - {{title}}: {{snippet}}
        {{/search.results}}
    routing:
      - out: true
```

### LLM with Tool Access

Let the LLM decide which tools to call:

```yaml
nodes:
  assistant:
    mcp.exec:
      component: llm
      action: chat
      args:
        model: gpt-4o
        system: "You are a helpful assistant. Use tools when needed."
        user: "{{in.text}}"
        tools:
          - name: search_docs
            description: Search the knowledge base
          - name: calculate
            description: Perform mathematical calculations
          - name: send_email
            description: Send an email to a user
    routing:
      - to: respond
```

### Tool Execution Flow

```
User Query
    ↓
LLM receives query + tool definitions
    ↓
LLM decides to call tool
    ↓
MCP Executor runs tool
    ↓
Result returned to LLM
    ↓
LLM formulates response
    ↓
Response to user
```

## Creating Custom Tools

### Tool Configuration

Define tools in `mcp-config.json`:

```json
{
  "tools": {
    "get_weather": {
      "type": "http",
      "endpoint": "https://api.weatherapi.com/v1/current.json",
      "method": "GET",
      "description": "Get current weather for a city",
      "auth": {
        "type": "api-key",
        "header": "key",
        "secret": "WEATHER_API_KEY"
      },
      "schema": {
        "input": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "City name or coordinates"
            }
          },
          "required": ["q"]
        }
      }
    }
  }
}
```

### Tool as Wasm Component

Create a component that implements the tool interface:

```rust
// src/lib.rs
use greentic_interfaces_guest::prelude::*;

component_entrypoint!(WeatherTool);

struct WeatherTool;

impl ComponentHandler for WeatherTool {
    fn handle(request: ComponentRequest) -> ComponentResponse {
        let config: WeatherConfig = request.config()?;
        let city = config.q;

        // Fetch weather data
        let weather = fetch_weather(&city)?;

        ComponentResponse::ok(json!({
            "temperature": weather.temp_c,
            "conditions": weather.condition.text,
            "humidity": weather.humidity
        }))
    }
}
```

### Register in Flow

Use the CLI to bind the component:

```bash
greentic-flow bind-component --flow main.ygtc --step get_weather \
  --local-wasm target/wasm32-wasip2/release/weather_tool.wasm
```

Then use in your flow:

```yaml
nodes:
  get_weather:
    mcp.exec:
      component: weather_tool
      action: fetch
      args:
        q: "{{collect_location.city}}"
    routing:
      - to: respond
```

## Tool Patterns

### Retrieval Augmented Generation (RAG)

```yaml
id: rag-flow
type: messaging
start: embed_query

nodes:
  embed_query:
    mcp.exec:
      component: llm
      action: embed
      args:
        model: text-embedding-3-small
        input: "{{in.text}}"
    routing:
      - to: search

  search:
    mcp.exec:
      component: vector_db
      action: search
      args:
        embedding: embed_query.embedding
        collection: docs
        top_k: 5
    routing:
      - to: generate

  generate:
    mcp.exec:
      component: llm
      action: chat
      args:
        model: gpt-4o
        system: |
          Answer questions using only the provided context.
          Always cite your sources.
        user: |
          Question: {{in.text}}

          Context:
          {{#search.results}}
          Document: {{title}}
          {{content}}
          ---
          {{/search.results}}
    routing:
      - to: respond

  respond:
    templating.handlebars:
      text: "{{generate.payload.text}}"
    routing:
      - out: true
```

### Multi-Step Tools

Chain multiple tools:

```yaml
nodes:
  research:
    mcp.exec:
      component: llm
      action: chat
      args:
        model: gpt-4o
        tools:
          - name: web_search
            description: Search the web
          - name: fetch_url
            description: Fetch and extract content from a URL
          - name: save_note
            description: Save a research note
        system: |
          Research the topic by:
          1. Searching the web
          2. Fetching relevant pages
          3. Saving key findings
        user: "Research: {{in.text}}"
    routing:
      - to: summarise
```

### Confirmable Tools

Require user confirmation for sensitive operations:

```yaml
nodes:
  confirm_action:
    qa.process:
      questions:
        - id: confirm
          prompt: "Are you sure you want to delete your account? This cannot be undone."
          answer_type: choice
          options:
            - "Yes, delete my account"
            - "No, cancel"
    routing:
      - to: delete_account
      - to: cancelled

  delete_account:
    when:
      expression: "{{confirm_action.confirm}} == 'Yes, delete my account'"
    mcp.exec:
      component: account_manager
      action: delete
      args:
        user_id: "{{session.user_id}}"
    routing:
      - out: true

  cancelled:
    when:
      expression: "{{confirm_action.confirm}} != 'Yes, delete my account'"
    templating.handlebars:
      text: "Account deletion cancelled."
    routing:
      - out: true
```

## Tool Security

### Capability Restrictions

Define capabilities in `mcp-config.json`:

```json
{
  "tools": {
    "query_database": {
      "type": "sql",
      "capabilities": {
        "allowed_tables": ["users", "orders"],
        "max_rows": 100,
        "read_only": true
      }
    }
  }
}
```

### Rate Limiting

```json
{
  "tools": {
    "external_api": {
      "type": "http",
      "endpoint": "https://api.example.com",
      "rate_limit": {
        "requests": 10,
        "period": "1m"
      }
    }
  }
}
```

### Audit Logging

All tool executions are logged:

```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "tool": "query_database",
  "tenant": "acme-corp",
  "flow_id": "support-flow",
  "node_id": "lookup_user",
  "args": {"user_id": "***"},
  "duration_ms": 45,
  "success": true
}
```

Sensitive arguments are redacted in logs.

## Best Practices

1. **Write clear descriptions** — LLMs use these to decide when to call tools
2. **Define parameter constraints** — Use enums and validation
3. **Handle errors gracefully** — Return informative error messages
4. **Keep tools focused** — One tool, one purpose
5. **Test with various inputs** — LLMs can be creative with parameters
6. **Use capabilities** — Restrict tool access to minimum required
7. **Add rate limits** — Prevent runaway tool usage

## Troubleshooting

### Tool not being called

- Check the tool description is clear and specific
- Verify the LLM system prompt mentions when to use the tool
- Test with explicit instructions like "Use the search tool to find..."

### Tool returning errors

- Validate parameter types match the schema
- Check API credentials in secrets store
- Review error logs for detailed messages
- Verify network access is enabled in capabilities

### Slow tool execution

- Check endpoint latency
- Consider caching for repeated queries
- Use async patterns for long-running tools

## Related

- [MCP Overview](/docs/mcp/overview) — MCP concepts
- [MCP Integration](/docs/mcp/integration) — Connecting tools to flows
- [Components](/docs/architecture/components) — Building tool components
- [OAuth](/docs/oauth/overview) — Authentication for tools
