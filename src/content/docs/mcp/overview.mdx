---
title: MCP Overview
description: Integrate external tools and data into your digital workers using the Model Context Protocol.
order: 1
---

# MCP Integration

The Model Context Protocol (MCP) enables digital workers to interact with external tools and data sources. Greentic provides native MCP support through the `greentic-mcp` module.

## What is MCP?

MCP is a standard protocol for connecting AI models to external capabilities:

- **Tools** — Functions the AI can call (search, calculate, send email)
- **Resources** — Data sources the AI can read (documents, databases)
- **Prompts** — Reusable prompt templates

## Architecture

import { McpArchitectureDiagram } from '@/components/diagrams/McpArchitectureDiagram';

<McpArchitectureDiagram client:load className="my-8" />

## Using MCP Tools in Flows

### The mcp.exec Operation

Call MCP tools using the `mcp.exec` operation in YGTc v2 flows:

```yaml
nodes:
  search:
    mcp.exec:
      component: vector_db
      action: search
      args:
        query: "{{state.user_query}}"
        top_k: 5
    routing:
      - to: process_results
```

### LLM with Tool Access

Execute LLM calls that can use tools:

```yaml
nodes:
  assistant:
    mcp.exec:
      component: llm
      action: chat
      args:
        model: gpt-4o
        system: "You are a helpful assistant with access to tools."
        user: "{{in.text}}"
        tools:
          - name: search
            description: Search the knowledge base
          - name: calculate
            description: Perform calculations
    routing:
      - to: respond
```

### Weather API Example

```yaml
id: weather-flow
type: messaging
start: collect_location

nodes:
  collect_location:
    qa.process:
      welcome: "Hi! I can tell you the weather."
      questions:
        - id: location
          prompt: "Which city?"
          answer_type: text
    routing:
      - to: get_weather

  get_weather:
    mcp.exec:
      component: weather_api
      action: forecast_weather
      args:
        q: collect_location.location
        days: 3
    routing:
      - to: respond

  respond:
    templating.handlebars:
      text: |
        Weather for {{get_weather.payload.location.name}}:
        Temperature: {{get_weather.payload.current.temp_c}}°C
        Condition: {{get_weather.payload.current.condition.text}}
    routing:
      - out: true
```

## Configuring MCP Tools

Tools are configured in `mcp-config.json`:

```json
{
  "tools": {
    "weather-api": {
      "type": "http",
      "endpoint": "https://api.weatherapi.com/v1/forecast.json",
      "method": "GET",
      "auth": {
        "type": "api-key",
        "header": "key",
        "secret": "WEATHER_API_KEY"
      },
      "schema": {
        "input": {
          "type": "object",
          "properties": {
            "q": { "type": "string", "description": "Location query" },
            "days": { "type": "integer", "default": 1 }
          },
          "required": ["q"]
        }
      }
    }
  }
}
```

### Tool Types

| Type | Description |
|------|-------------|
| `http` | REST API call |
| `grpc` | gRPC service call |
| `wasm` | Local Wasm component |
| `exec` | Shell command (sandboxed) |

### Authentication

Supported auth methods:

```json
// API Key
"auth": {
  "type": "api-key",
  "header": "Authorization",
  "prefix": "Bearer ",
  "secret": "MY_API_KEY"
}

// OAuth (via greentic-oauth)
"auth": {
  "type": "oauth",
  "provider": "msgraph",
  "scopes": ["Mail.Read", "Chat.ReadWrite"]
}

// mTLS
"auth": {
  "type": "mtls",
  "cert": "/certs/client.pem",
  "key": "/certs/client-key.pem"
}
```

## WIT Interface

The MCP adapter implements the `wasix:mcp` interface:

```wit
// wasix:mcp@25.06.18
package wasix:mcp@25.06.18;

interface tools {
    record tool-call {
        name: string,
        arguments: string,  // JSON
    }

    record tool-result {
        content: string,    // JSON
        is-error: bool,
    }

    call-tool: func(call: tool-call) -> tool-result;
    list-tools: func() -> list<tool-descriptor>;
}
```

## Creating Custom Tools

### Define the Tool Schema

```json
{
  "tools": {
    "my-tool": {
      "type": "http",
      "endpoint": "http://my-service/api",
      "method": "POST",
      "schema": {
        "input": {
          "type": "object",
          "properties": {
            "data": { "type": "string" }
          },
          "required": ["data"]
        },
        "output": {
          "type": "object",
          "properties": {
            "result": { "type": "string" }
          }
        }
      }
    }
  }
}
```

### Use in Flows

```yaml
nodes:
  process:
    mcp.exec:
      component: my-service
      action: my-tool
      args:
        data: "{{in.text}}"
    routing:
      - to: respond
```

## Standard Tool Library

Greentic provides common tools out of the box:

| Tool | Description |
|------|-------------|
| `web-search` | Search the web |
| `web-fetch` | Fetch a URL |
| `file-read` | Read files |
| `file-write` | Write files |
| `http-request` | Generic HTTP |
| `sql-query` | Database queries |

### Example: Web Fetch

```yaml
nodes:
  fetch:
    mcp.exec:
      component: http_tools
      action: fetch
      args:
        url: "https://api.example.com/data"
        method: GET
        headers:
          Accept: application/json
    routing:
      - to: process
```

## Error Handling

Tools can fail. Use conditional routing to handle errors:

```yaml
nodes:
  fetch_data:
    mcp.exec:
      component: api
      action: fetch
      args:
        endpoint: "{{state.url}}"
    routing:
      - to: handle_error
      - to: process_data

  handle_error:
    when:
      expression: "{{fetch_data.error}} != null"
    templating.handlebars:
      text: "Sorry, I couldn't fetch that data: {{fetch_data.error}}"
    routing:
      - out: true

  process_data:
    when:
      expression: "{{fetch_data.error}} == null"
    templating.handlebars:
      text: "Here's your data: {{fetch_data.payload}}"
    routing:
      - out: true
```

## Rate Limiting

Configure rate limits per tool:

```json
{
  "tools": {
    "api-call": {
      "type": "http",
      "endpoint": "...",
      "rate_limit": {
        "requests": 100,
        "period": "1m"
      }
    }
  }
}
```

## Observability

All tool calls are traced with OpenTelemetry:

```
Span: mcp.exec.weather
├── component: weather_api
├── action: forecast_weather
├── args: {"q": "London", "days": 3}
├── duration: 234ms
├── status: success
└── result_size: 1.2KB
```

## Security

### Capability Controls

Tools require explicit capability grants in component manifests:

```json
{
  "capabilities": {
    "network": true,
    "secrets": ["WEATHER_API_KEY", "DB_PASSWORD"]
  }
}
```

### Sandboxing

Tool execution is sandboxed:
- No access to host filesystem (except explicitly granted)
- Network restricted to allowed endpoints
- CPU and memory limits enforced
- Secrets only accessible via the secrets store

## Component Bindings

MCP tools are bound to nodes via the sidecar file:

```json
{
  "schema_version": 1,
  "nodes": {
    "get_weather": {
      "source": {
        "kind": "remote",
        "reference": "oci://ghcr.io/greentic-ai/components/weather-mcp:0.1.0"
      }
    }
  }
}
```

Use the CLI to manage bindings:

```bash
greentic-flow bind-component --flow main.ygtc --step get_weather \
  --component oci://ghcr.io/greentic-ai/components/weather-mcp:0.1.0
```

## Next Steps

- **[MCP Tools Reference](/docs/mcp/tools)** — Full tool documentation
- **[MCP Integration Guide](/docs/mcp/integration)** — Advanced patterns
- **[Tutorial: RAG System](/tutorials/demo-3-rag-system)** — MCP in practice
- **[OAuth](/docs/oauth/overview)** — OAuth for tool authentication
