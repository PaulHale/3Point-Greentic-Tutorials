---
title: Flows
description: YGTC flow definitions - the declarative orchestration language for Greentic digital workers.
order: 3
---

# Flows

Flows are declarative YAML files (`.ygtc`) that define how components are wired together to create digital workers. They are the orchestration layer of Greentic.

## Flow Structure

Every YGTc v2 flow has this basic structure:

```yaml
# Required metadata
id: my-flow
type: messaging
start: first_node

# Optional metadata
title: My Flow
description: Description of what this flow does

# Optional flow-level parameters
parameters:
  default_value: 42

# Node definitions
nodes:
  first_node:
    qa.process:
      welcome: "Hello!"
      questions:
        - id: name
          prompt: "What's your name?"
          answer_type: text
    routing:
      - to: second_node

  second_node:
    templating.handlebars:
      text: "Nice to meet you, {{first_node.name}}!"
    routing:
      - out: true
```

## Flow Types

Flows can be one of several types:

| Type | Trigger | Use Case |
|------|---------|----------|
| `messaging` | Incoming message | Chat bots, support agents |
| `webhook` | HTTP webhook | Triggered automation |
| `timer` | Schedule | Background tasks |
| `websocket` | WebSocket connection | Real-time communication |
| `pubsub` | Pub/sub events | Event-driven automation |

### Messaging Flows

Most common type. Triggered by messages from channels:

```yaml
id: support-bot
type: messaging
title: IT Support Assistant
start: greet
```

### Webhook Flows

Triggered by external HTTP webhooks:

```yaml
id: github-webhook
type: webhook
title: GitHub Integration
start: process_event
```

### Timer Flows

Triggered on a schedule:

```yaml
id: daily-report
type: timer
title: Daily Report Generator
start: generate
```

## Nodes

Nodes are the steps in a flow. Each node invokes an operation with configuration.

### Basic Node

```yaml
nodes:
  process:
    mcp.exec:
      component: llm
      action: chat
      args:
        model: gpt-4o
        temperature: 0.7
    routing:
      - to: respond
```

Key points:
- **One operation key** per node (e.g., `mcp.exec`, `qa.process`, `templating.handlebars`)
- **Config directly under operation** — no `config:` wrapper
- **Routing as array** with `to:`, `out:`, or `reply:` keys

### Node with Q&A

The `qa.process` operation collects structured information:

```yaml
nodes:
  collect_info:
    qa.process:
      welcome: "Hi! I need some information."
      questions:
        - id: issue
          prompt: "Please describe your issue:"
          answer_type: text
          required: true
        - id: urgency
          prompt: "How urgent is this?"
          answer_type: choice
          options:
            - Low
            - Medium
            - High
    routing:
      - to: process
```

### Node with MCP Tool

Execute MCP tools with `mcp.exec`:

```yaml
nodes:
  call_api:
    mcp.exec:
      component: weather_api
      action: forecast_weather
      args:
        q: collect_info.location
        days: 3
    routing:
      - to: format_response
```

### Node with Template

Render dynamic content with `templating.handlebars`:

```yaml
nodes:
  respond:
    templating.handlebars:
      text: |
        Weather for {{call_api.payload.location.name}}:
        Temperature: {{call_api.payload.current.temp_c}}°C
        Condition: {{call_api.payload.current.condition.text}}
    routing:
      - out: true
```

## Routing

Routing determines which node executes next.

### Simple Routing

```yaml
# Route to another node
routing:
  - to: next_node

# Terminal - end the flow
routing:
  - out: true

# Shorthand terminal
routing: out
```

### Multiple Routes (Fan-out)

```yaml
routing:
  - to: handler_a
  - to: handler_b
```

### Reply and Continue

```yaml
routing:
  - reply: true
  - to: next_node
```

### Conditional Routing

Use `when` on target nodes:

```yaml
nodes:
  classify:
    mcp.exec:
      component: classifier
      action: classify
      args:
        text: "{{in.text}}"
    routing:
      - to: high_priority
      - to: normal_priority

  high_priority:
    when:
      expression: "{{classify.priority}} == 'high'"
    templating.handlebars:
      text: "Urgent! Processing immediately."
    routing: out

  normal_priority:
    when:
      expression: "{{classify.priority}} != 'high'"
    templating.handlebars:
      text: "Added to queue."
    routing: out
```

## Parameters

Flow-level parameters are accessible throughout the flow:

```yaml
parameters:
  model: gpt-4o
  max_tokens: 1000
  api_timeout: 30

nodes:
  call_llm:
    mcp.exec:
      component: llm
      action: chat
      args:
        model: parameters.model
        max_tokens: parameters.max_tokens
```

## Data References

Reference data from previous nodes using dot notation:

### Previous Node Output

```yaml
# Reference output from 'collect_info' node
text: "Hello {{collect_info.name}}!"
location: collect_info.q_location
```

### Nested Properties

```yaml
# Access nested data
city: "{{api_call.payload.location.name}}"
temp: "{{api_call.payload.current.temp_c}}"
```

### Handlebars Iteration

```yaml
templating.handlebars:
  text: |
    Results:
    {{#api_call.payload.items}}
    - {{name}}: {{value}}
    {{/api_call.payload.items}}
```

### Parameters

```yaml
# Reference flow parameters
days: parameters.days_default
```

## Complete Example

Here's a complete IT support flow:

```yaml
id: it-support
type: messaging
title: IT Support Assistant
description: Intelligent IT support with classification and routing
start: greet

parameters:
  escalation_timeout: 30

nodes:
  greet:
    templating.handlebars:
      text: |
        Welcome to IT Support!
        I can help with password resets, hardware issues, and software problems.
        Please describe your issue.
    routing:
      - to: collect_info

  collect_info:
    qa.process:
      questions:
        - id: issue_description
          prompt: "Please describe your issue in detail:"
          answer_type: text
          required: true
        - id: urgency
          prompt: "How urgent is this?"
          answer_type: choice
          options:
            - Low - Can wait a few days
            - Medium - Need help today
            - High - Blocking my work
    routing:
      - to: classify

  classify:
    mcp.exec:
      component: llm
      action: chat
      args:
        model: gpt-4o
        temperature: 0
        system: |
          Classify this IT issue into: password, hardware, software, network, or other.
          Respond with ONLY the category name.
        user: "Issue: {{in.issue_description}}"
    routing:
      - to: password_handler
      - to: hardware_handler
      - to: general_handler

  password_handler:
    when:
      expression: "{{classify.payload.text}} == 'password'"
    templating.handlebars:
      text: |
        I can help you reset your password.
        Please visit: https://password.company.com/reset

        If you need further assistance, reply with "help".
    routing: out

  hardware_handler:
    when:
      expression: "{{classify.payload.text}} == 'hardware'"
    templating.handlebars:
      text: |
        I'll create a hardware support ticket for you.

        Issue: {{in.issue_description}}
        Urgency: {{in.urgency}}

        A technician will contact you within 24 hours.
    routing: out

  general_handler:
    when:
      expression: "{{classify.payload.text}} != 'password' && {{classify.payload.text}} != 'hardware'"
    mcp.exec:
      component: llm
      action: chat
      args:
        model: gpt-4o
        system: You are a helpful IT support assistant. Be concise but thorough.
        user: "Please help with: {{in.issue_description}}"
    routing:
      - to: respond

  respond:
    templating.handlebars:
      text: "{{general_handler.payload.text}}"
    routing: out
```

## Sidecar Files

YGTc v2 flows use a **sidecar file** (`<flow>.ygtc.resolve.json`) to track which components back each node. This separates flow logic from component sources:

```json
{
  "schema_version": 1,
  "nodes": {
    "collect_info": {
      "source": {
        "kind": "remote",
        "reference": "oci://ghcr.io/greentic-ai/components/qa:0.1.0"
      }
    },
    "classify": {
      "source": {
        "kind": "local",
        "path": "components/llm/target/wasm32-wasip2/release/llm.wasm"
      }
    }
  }
}
```

The sidecar is managed by `greentic-flow` CLI commands (`add-step`, `bind-component`, `doctor`).

## Validation

Always validate flows before deployment:

```bash
# Validate a single flow
greentic-flow doctor flows/my-flow.ygtc

# Validate all flows in a directory
greentic-flow doctor flows/

# JSON output for CI
greentic-flow doctor --json flows/my-flow.ygtc
```

This checks:
- Valid YAML syntax
- Required fields present
- Node references exist
- Routing targets valid
- Component bindings in sidecar

## Best Practices

### Name Nodes Descriptively

```yaml
# Good
collect_issue:
classify_request:
send_response:

# Bad
node1:
step2:
x:
```

### Keep Flows Focused

One flow, one purpose. Compose flows rather than creating monolithic ones.

### Handle All Branches

Always have fallback routes for unexpected cases.

### Use Parameters

Extract configurable values to `parameters:` for easy adjustment.

### Version Your Flows

Include title and description for tracking changes.

## Next Steps

- **[Packs](/docs/architecture/packs)** — Bundling flows for distribution
- **[YGTC Schema Reference](/docs/reference/ygtc-schema)** — Full schema documentation
- **[CLI Reference](/docs/reference/cli)** — Flow CLI commands
- **[Tutorial: IT Support Bot](/tutorials/demo-2-it-support)** — Step-by-step flow building
