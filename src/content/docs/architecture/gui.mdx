---
title: "GUI Runtime"
description: "Visual runtime environment for developing, debugging, and testing Greentic flows locally."
---

import { GUIRuntimeDiagram } from '@/components/diagrams/GUIRuntimeDiagram';

# GUI Runtime

The GUI Runtime (`greentic-gui`) provides a visual environment for developing, debugging, and testing flows locally before deployment.

## Overview

The GUI Runtime provides:

- **Visual Flow Execution** — Watch flows execute step-by-step in real-time
- **State Inspection** — Debug session state, variables, and context
- **Message Monitoring** — View all inbound and outbound messages
- **Trace Visualisation** — OpenTelemetry trace rendering with timing

## Architecture

<GUIRuntimeDiagram client:load className="my-8" />

## Core Components

### Flow Canvas

The Flow Canvas provides a visual representation of your flow as it executes:

- **Node Highlighting** — Active nodes are highlighted during execution
- **Edge Animation** — Data flow is animated between nodes
- **Zoom & Pan** — Navigate large flows with ease
- **Selection** — Click nodes to inspect their configuration

### State Inspector

Real-time inspection of all runtime state:

```typescript
// Example state structure visible in inspector
{
  session: {
    id: "sess_abc123",
    tenant: "acme-corp",
    started: "2024-01-15T10:30:00Z"
  },
  variables: {
    user_name: "Alice",
    ticket_id: "TICK-456",
    priority: "high"
  },
  context: {
    current_node: "process_request",
    iteration: 3
  }
}
```

### Message Panel

View all messages flowing through your flow:

| Direction | Type | Description |
|-----------|------|-------------|
| **Inbound** | User message | Messages from the simulated user |
| **Outbound** | Bot response | Responses generated by the flow |
| **Internal** | Component call | Inter-component communication |
| **System** | Event | System events and triggers |

### Trace Viewer

Integrated OpenTelemetry trace visualisation:

- **Span Tree** — Hierarchical view of all spans
- **Timing Bars** — Visual duration comparison
- **Attributes** — Full span attribute inspection
- **Errors** — Highlighted error spans with stack traces

## Getting Started

### Installation

The GUI Runtime is included with the Greentic developer tools:

```bash
# Install via npm
npm install -g @greentic/gui

# Or via cargo
cargo install greentic-gui
```

### Running Locally

```bash
# Start GUI with a pack
greentic-gui run --pack ./my-pack.gtpack

# Start GUI with a flow file (development mode)
greentic-gui dev --flow ./flows/my-flow.ygtc

# Start with mock services enabled
greentic-gui dev --flow ./flows/my-flow.ygtc --mocks
```

### Configuration

```toml
# ~/.greentic/gui.toml

[server]
port = 8080
host = "127.0.0.1"

[ui]
theme = "dark"
show_traces = true
auto_scroll_messages = true

[mocks]
enabled = true
llm_provider = "echo"  # echo, random, or openai
delay_ms = 100

[telemetry]
otlp_endpoint = "http://localhost:4317"
```

## Development Workflow

### 1. Create Flow

Write your flow using YGTc v2 syntax:

```yaml
id: support-flow
type: messaging
start: greet

nodes:
  greet:
    templating.handlebars:
      template: "Hello! How can I help you today?"
    routing:
      - to: process
```

### 2. Launch GUI

```bash
greentic-gui dev --flow support-flow.ygtc --mocks
```

### 3. Interact

Use the built-in chat interface to send messages and watch the flow execute.

### 4. Debug

- Click nodes in the Flow Canvas to inspect their configuration
- Use the State Inspector to view variables
- Check the Trace Viewer for performance issues
- Review the Message Panel for I/O details

### 5. Iterate

Make changes to your flow file — the GUI automatically reloads.

## Mock Services

The GUI Runtime includes mock implementations for common services:

### LLM Mocks

```yaml
# Mock configuration
mocks:
  llm:
    provider: echo      # Returns input as output
    # provider: random  # Returns random responses
    # provider: openai  # Uses real OpenAI (requires API key)
```

### HTTP Mocks

```yaml
mocks:
  http:
    endpoints:
      - path: /api/tickets
        method: GET
        response:
          status: 200
          body: '{"tickets": []}'
```

### State Mocks

```yaml
mocks:
  state:
    initial:
      user_preferences:
        language: en
        timezone: UTC
```

## Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| `Space` | Pause/Resume execution |
| `S` | Step to next node |
| `R` | Restart flow |
| `I` | Toggle State Inspector |
| `M` | Toggle Message Panel |
| `T` | Toggle Trace Viewer |
| `Ctrl+Z` | Undo last action |
| `Ctrl+Shift+Z` | Redo action |

## Best Practices

### Development

1. **Start with mocks** — Use mock services during initial development
2. **Test edge cases** — Use the chat interface to test various inputs
3. **Watch traces** — Monitor performance from the start
4. **Inspect state** — Verify state changes match expectations

### Debugging

1. **Set breakpoints** — Click nodes to pause execution at specific points
2. **Step through** — Use step mode for complex logic
3. **Check variables** — Verify variable values in the State Inspector
4. **Review traces** — Look for unexpected latency

## Related

- [Flows](/docs/architecture/flows) — Flow structure and syntax
- [Components](/docs/architecture/components) — Component architecture
- [CLI Reference](/docs/reference/cli) — Command-line tools
- [WebChat](/docs/messaging/webchat) — Production chat widget
