---
title: Components
description: Understanding WebAssembly components in Greentic - the building blocks of digital workers.
order: 2
---

import { ComponentAnatomy } from '@/components/diagrams/ComponentAnatomy';

# Components

Components are the building blocks of Greentic. They are self-describing WebAssembly modules that execute specific logic in a secure sandbox.

## What is a Component?

A component is a compiled Wasm module that:

- Implements a standard interface (`greentic:component`)
- Declares its capabilities and configuration schema
- Runs in complete isolation from other components
- Can be versioned, signed, and distributed

## Component Structure

Every component has this file structure:

```
component-name/
├── Cargo.toml                    # Rust package manifest
├── component.manifest.json       # Component metadata
├── src/
│   └── lib.rs                    # Implementation
├── schemas/
│   └── v1/
│       └── config.schema.json    # Configuration schema
└── wit/
    └── world.wit                 # WIT interface definition
```

<ComponentAnatomy client:load className="my-8" />

### The Manifest

The `component.manifest.json` describes the component:

```json
{
  "$schema": "https://greentic-ai.github.io/greentic-component/schemas/v1/component.manifest.schema.json",
  "name": "my-component",
  "version": "0.1.0",
  "description": "Description of what this component does",
  "author": "Your Name",
  "capabilities": {
    "network": true,
    "secrets": ["API_KEY"]
  },
  "config_schema": "schemas/v1/config.schema.json",
  "operations": {
    "handle_message": {
      "description": "Process an incoming message",
      "config_schema": "schemas/v1/handle_message.schema.json"
    }
  }
}
```

### The Implementation

Components use the `component_entrypoint!` macro:

```rust
// src/lib.rs
use greentic_interfaces_guest::prelude::*;

component_entrypoint!(MyComponent);

struct MyComponent;

impl ComponentHandler for MyComponent {
    fn handle(request: ComponentRequest) -> ComponentResponse {
        // Access configuration
        let config: MyConfig = request.config()?;

        // Access the message
        let message = request.message();

        // Process and return response
        let result = process_message(&config, message);

        ComponentResponse::ok(result)
    }
}
```

### dev_flows for Configuration

Components can provide `dev_flows` that guide configuration:

```rust
impl ComponentDevFlows for MyComponent {
    fn dev_flows() -> DevFlowsSpec {
        DevFlowsSpec::builder()
            .add_question("api_key", "What is your API key?", QuestionType::Secret)
            .add_question("model", "Which model to use?", QuestionType::Choice {
                options: vec!["gpt-4o", "gpt-4o-mini", "claude-3"]
            })
            .build()
    }
}
```

This enables the CLI to interactively configure flows:

```bash
greentic-flow add-step --flow main.ygtc --mode config \
  --node-id llm \
  --component oci://ghcr.io/greentic-ai/components/llm:latest
```

### The Configuration Schema

JSON Schema defines valid configuration:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "model": {
      "type": "string",
      "description": "Model to use",
      "default": "gpt-4o"
    },
    "temperature": {
      "type": "number",
      "minimum": 0,
      "maximum": 2,
      "default": 0.7
    },
    "max_tokens": {
      "type": "integer",
      "minimum": 1,
      "maximum": 128000
    }
  },
  "required": ["model"]
}
```

## Standard Components

Greentic provides several standard components:

### LLM Components

| Component | Description |
|-----------|-------------|
| `component-llm-openai` | OpenAI GPT models |
| `component-llm-anthropic` | Anthropic Claude models |
| `component-llm-azure` | Azure OpenAI service |

### UI Components

| Component | Description |
|-----------|-------------|
| `component-adaptive-card` | Microsoft Adaptive Card rendering |
| `component-templates` | Handlebars-style templating |
| `component-oauth-card` | OAuth authentication cards |

### Processing Components

| Component | Description |
|-----------|-------------|
| `component-script-rhai` | Rhai scripting engine |
| `component-qa-process` | Structured Q&A collection |
| `component-flow2flow` | Flow composition |

## Creating a Custom Component

### 1. Scaffold

Use the CLI to create a new component:

```bash
greentic-component new --name my-component --org ai.greentic --path ./components
```

This creates a complete project structure with:
- Cargo.toml configured for `wasm32-wasip2`
- Component manifest
- WIT bindings
- Example implementation

### 2. Implement

Edit `src/lib.rs` to implement your logic:

```rust
use greentic_interfaces_guest::prelude::*;
use serde::{Deserialize, Serialize};

component_entrypoint!(MyComponent);

#[derive(Deserialize)]
struct Config {
    setting: String,
    value: i32,
}

#[derive(Serialize)]
struct Output {
    result: String,
}

struct MyComponent;

impl ComponentHandler for MyComponent {
    fn handle(request: ComponentRequest) -> ComponentResponse {
        let config: Config = request.config()?;
        let message = request.message();

        // Your custom logic here
        let result = format!("Processed: {} with {}", message.text, config.setting);

        ComponentResponse::ok(Output { result })
    }
}
```

### 3. Build

Compile to WebAssembly:

```bash
cargo build --target wasm32-wasip2 --release
```

The compiled component will be at:
```
target/wasm32-wasip2/release/my_component.wasm
```

### 4. Validate

Check your component is valid:

```bash
greentic-component validate --path .
```

### 5. Test

Test locally in a flow:

```yaml
id: test-flow
type: messaging
start: test

nodes:
  test:
    handle_message:
      setting: "test-value"
      value: 42
    routing:
      - out: true
```

Remember to create the sidecar file or use the CLI to bind the component:

```bash
greentic-flow bind-component --flow flows/test.ygtc --step test \
  --local-wasm target/wasm32-wasip2/release/my_component.wasm
```

## Capabilities

Components declare required capabilities in their manifest:

| Capability | Description |
|------------|-------------|
| `network` | HTTP/HTTPS outbound access |
| `filesystem` | Read/write file access |
| `secrets` | Access to named secrets |
| `state` | Key-value state storage |
| `session` | Session management |

The runtime enforces these capabilities. A component without `network` capability cannot make HTTP requests.

```json
{
  "capabilities": {
    "network": true,
    "secrets": ["API_KEY", "DATABASE_URL"],
    "state": true,
    "filesystem": false
  }
}
```

## Host Interfaces

Components can use host-provided interfaces:

### Secrets Store

```rust
use greentic_interfaces_guest::secrets::SecretsStore;

let api_key = SecretsStore::get("API_KEY")?;
```

### State Store

```rust
use greentic_interfaces_guest::state::StateStore;

// Get state
let count: i32 = StateStore::get("counter")?.unwrap_or(0);

// Set state
StateStore::set("counter", count + 1)?;
```

### HTTP Client

```rust
use greentic_interfaces_guest::http::HttpClient;

let response = HttpClient::get("https://api.example.com/data")
    .header("Authorization", format!("Bearer {}", api_key))
    .send()?;
```

### Session Management

```rust
use greentic_interfaces_guest::session::Session;

// Pause session (for long operations)
Session::pause("waiting_for_approval")?;

// Session will resume when triggered
```

## Best Practices

### Keep Components Focused

Each component should do one thing well. Prefer many small components over few large ones.

### Validate Early

Use JSON Schema to validate all inputs. Reject invalid data at the boundary.

### Handle Errors Gracefully

Return meaningful error responses rather than panicking:

```rust
fn handle(request: ComponentRequest) -> ComponentResponse {
    match try_process(&request) {
        Ok(result) => ComponentResponse::ok(result),
        Err(e) => ComponentResponse::error(format!("Processing failed: {}", e)),
    }
}
```

### Document Configuration

Provide clear descriptions in your JSON Schema. Developers will see these in tooling.

### Use dev_flows

Implement `dev_flows` to guide users through configuration. This creates a better developer experience than raw JSON configuration.

### Version Thoughtfully

Follow semver. Breaking changes require a major version bump.

## Distribution

### OCI Registry

Publish components to OCI registries:

```bash
# Tag and push
oras push ghcr.io/greentic-ai/components/my-component:0.1.0 \
  target/wasm32-wasip2/release/my_component.wasm:application/wasm \
  component.manifest.json:application/json
```

### In Packs

Components are typically distributed within packs:

```bash
greentic-pack build --in ./project --gtpack-out dist/my-pack.gtpack
```

## Next Steps

- **[Flows](/docs/architecture/flows)** — How components are wired together
- **[Packs](/docs/architecture/packs)** — Bundling components for distribution
- **[Component Manifest Reference](/docs/reference/component-manifest)** — Full manifest specification
- **[MCP Integration](/docs/mcp/overview)** — Using MCP tools in components
